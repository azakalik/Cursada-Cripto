# Ejercicio 1
## Parte 1
El problema es que se esta manteniendo la **confidencialidad** del mensaje, ya que un atacanta que no conoce la clave no puede ver ni el valor sensado ni los datos adicionales, pero no se esta manteniendo la **integridad** del mensaje. De esta forma, un atacante podria interceptar un paquete que viene de un sensor, modificar los ultimos bytes y luego enviar ese paquete al dispositivo maestro. Lo que terminaria pasando es que los datos adicionales se desencriptarian con un valor desconocido (lo cual potencialmente podria ser peligroso).
Una solucion a este problema podria ser utilizando firmas digitales. Cada sensor podria enviar $\#sensor||e_k(\#sensor||valor\_sensado||datos\_adicionales)||sign_k(\#sensor||e_k(\#sensor||valor\_sensado||datos\_adicionales))$,
es decir, enviando tambien una firma (usando la clave K) del mensaje original.
De esta forma, el dispositivo maestro podra verificar la **integridad** del mensaje que le llego, y si usando la funcion **vrfy_k** se da cuenta de que el paquete fue alterado, entonces lo ignora.
## Parte 2
Este otro atacante esta haciendo un ataque de **replay**. La solucion consiste en implementar algun mecanismo que no permita que se envien mensajes repetidos.
Por ejemplo, podemos agregar un sequence number y un timestamp al mensaje de esta manera: $\#sensor||e_k(\#sensor||valor\_sensado||datos\_adicionales||timestamp||sequence\_number)$
Por lo tanto, el dispositivo maestro podra:
- Verificar que ese $sequence\_number$ no haya sido recibido ya
- Verificar que el $timestamp$ sea medianamente reciente (podemos usar una tolerancia de 1min por ejemplo), para que no haya atacantes enviando mensajes muy antiguos

# Ejercicio 2
## Opcion 1

# Ejercicio 3
## Parte A
Si el contenido de una noticia se postea igual que como se recibe sin ningun tipo de validacion, entonces hay muy grandes posibilidades de que se pueda hacer un ataque del tipo XSS.
Para ello, un atacante podria postear una noticia que contenga codigo javascript utilizando algo como esto:
<script>{codigo_malicioso}</script>
Cuando un usuario vaya a leer esa publicacion, ese codigo se ejecutara localmente en su computadora. El atacante podria hacer que el codigo lea las cookies de dicho usuario, y una vez que tenga las cookies se podria impersonar como el.
Suponemos que el atacante tambien publico unas publicaciones no infectadas (de recetas por ejemplo).
Entonces, el atacante podria hacer que todas las computadoras que corrieron el script malicioso empiecen a acceder a sus publicaciones, logrando asi tener grandes ingresos publicitarios, ya que sus noticias tendran un gran numero de vistas.
## Parte B
Si el endpoint permite que un atacante haga SSRF, entonces esto dejaria lugar a que el servidor haga un request a algun lugar elegido por el atacante.
Por ejemplo, el atacante podria pedir que el servidor haga un request a localhost/admin. Suponiendo que en esa direccion esta la pagina de administracion, el atacante podria hacer da√±o. Otra cosa que podria hacer es ratear una noticia a nombre del servidor, haciendo que este mismo se haga un GET a /{news_id}/positive
## Parte C
Es inseguro enviar las API KEYS de esa manera por una serie de motivos. Dentro de ellas:
- El navegador guarda en su historial las URL visitadas, entonces cualquiera que acceda al historial de navegacion del publicador de noticia podra ver su API KEY
- Es posible que el servidor guarde LOGS de que paginas fueron accedidas, revelando asi el API KEY de la personas
La mejor manera de hacerlo es enviando el API KEY en el body del HTTP Request